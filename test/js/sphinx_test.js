// Generated by CoffeeScript 1.8.0
(function() {
  var fs;

  fs = require('fs');

  describe('lib/sphinx/pocketsphinx.js', function() {
    before(function() {
      var Module, digitsJs, sphinxJs;
      sphinxJs = fs.readFileSync('lib/sphinx/pocketsphinx.js', {
        encoding: 'utf8'
      });
      digitsJs = fs.readFileSync('lib/sphinx/models/digits.js', {
        encoding: 'utf8'
      });
      Module = null;
      eval(sphinxJs + ";\n" + digitsJs);
      return this.sphinx = Module;
    });
    it('defines the right APIs', function() {
      expect(this.sphinx).to.have.property('AudioBuffer');
      expect(this.sphinx).to.have.property('Config');
      expect(this.sphinx).to.have.property('Integers');
      expect(this.sphinx).to.have.property('Recognizer');
      expect(this.sphinx).to.have.property('ReturnType');
      expect(this.sphinx).to.have.property('Segmentation');
      expect(this.sphinx).to.have.property('VectorTransitions');
      return expect(this.sphinx).to.have.property('VectorWords');
    });
    describe('ReturnType', function() {
      it('defines SUCCESS', function() {
        return expect(this.sphinx.ReturnType).to.have.property('SUCCESS');
      });
      it('defines BAD_STATE', function() {
        return expect(this.sphinx.ReturnType).to.have.property('BAD_STATE');
      });
      it('defines BAD_ARGUMENT', function() {
        return expect(this.sphinx.ReturnType).to.have.property('BAD_ARGUMENT');
      });
      return it('defines RUNTIME_ERROR', function() {
        return expect(this.sphinx.ReturnType).to.have.property('RUNTIME_ERROR');
      });
    });
    describe('AudioBuffer', function() {
      beforeEach(function() {
        return this.buffer = new this.sphinx.AudioBuffer();
      });
      afterEach(function() {
        return this.buffer["delete"]();
      });
      return it('works like a std::vector of shorts', function() {
        var i, _i, _j;
        expect(this.buffer.size()).to.equal(0);
        for (i = _i = 0; _i < 300; i = ++_i) {
          this.buffer.push_back(i * 100);
          this.buffer.push_back(-i * 100);
        }
        this.buffer.push_back(42);
        expect(this.buffer.size()).to.equal(601);
        for (i = _j = 0; _j < 300; i = ++_j) {
          expect(this.buffer.get(i * 2)).to.equal(i * 100);
          expect(this.buffer.get(i * 2 + 1)).to.equal(-i * 100);
        }
        expect(this.buffer.get(600)).to.equal(42);
        return expect(this.buffer.get(601)).to.equal(void 0);
      });
    });
    describe('Config', function() {
      beforeEach(function() {
        return this.config = new this.sphinx.Config();
      });
      afterEach(function() {
        return this.config["delete"]();
      });
      return it('works like a std::vector of string pairs', function() {
        expect(this.config.size()).to.equal(0);
        this.config.push_back(['-hmm', 'en']);
        expect(this.config.size()).to.equal(1);
        expect(this.config.get(0)[0]).to.equal('-hmm');
        expect(this.config.get(0)[1]).to.equal('en');
        return expect(this.config.get(1)).to.equal(void 0);
      });
    });
    describe('Integers', function() {
      beforeEach(function() {
        return this.vector = new this.sphinx.Integers();
      });
      afterEach(function() {
        return this.vector["delete"]();
      });
      return it('works like a std::vector of ints', function() {
        var i, _i, _j;
        expect(this.vector.size()).to.equal(0);
        for (i = _i = 0; _i < 300; i = ++_i) {
          this.vector.push_back(i * 10000);
          this.vector.push_back(-i * 10000);
        }
        this.vector.push_back(424242);
        expect(this.vector.size()).to.equal(601);
        for (i = _j = 0; _j < 300; i = ++_j) {
          expect(this.vector.get(i * 2)).to.equal(i * 10000);
          expect(this.vector.get(i * 2 + 1)).to.equal(-i * 10000);
        }
        expect(this.vector.get(600)).to.equal(424242);
        return expect(this.vector.get(601)).to.equal(void 0);
      });
    });
    describe('Segmentation', function() {
      beforeEach(function() {
        return this.segmentation = new this.sphinx.Segmentation();
      });
      afterEach(function() {
        return this.segmentation["delete"]();
      });
      return it('works like a std::vector of structs', function() {
        expect(this.segmentation.size()).to.equal(0);
        this.segmentation.push_back({
          start: 12,
          end: 13,
          word: 'hello world!'
        });
        expect(this.segmentation.size()).to.equal(1);
        expect(this.segmentation.get(0).start).to.equal(12);
        expect(this.segmentation.get(0).end).to.equal(13);
        expect(this.segmentation.get(0).word).to.equal('hello world!');
        return expect(this.segmentation.get(1)).to.equal(void 0);
      });
    });
    describe('VectorTransitions', function() {
      beforeEach(function() {
        return this.vector = new this.sphinx.VectorTransitions();
      });
      afterEach(function() {
        return this.vector["delete"]();
      });
      return it('works like a std::vector of structs', function() {
        expect(this.vector.size()).to.equal(0);
        this.vector.push_back({
          from: 12,
          to: 13,
          logp: 0,
          word: 'HELLO'
        });
        expect(this.vector.size()).to.equal(1);
        expect(this.vector.get(0).from).to.equal(12);
        expect(this.vector.get(0).to).to.equal(13);
        expect(this.vector.get(0).logp).to.equal(0);
        expect(this.vector.get(0).word).to.equal('HELLO');
        return expect(this.vector.get(1)).to.equal(void 0);
      });
    });
    describe('VectorWords', function() {
      beforeEach(function() {
        return this.vector = new this.sphinx.VectorWords();
      });
      afterEach(function() {
        return this.vector["delete"]();
      });
      return it('works like a std::vector of string pairs', function() {
        expect(this.vector.size()).to.equal(0);
        this.vector.push_back(['HELLO', 'HH AH L OW']);
        expect(this.vector.size()).to.equal(1);
        expect(this.vector.get(0)[0]).to.equal('HELLO');
        expect(this.vector.get(0)[1]).to.equal('HH AH L OW');
        return expect(this.vector.get(1)).to.equal(void 0);
      });
    });
    return describe('Recognizer', function() {
      beforeEach(function() {
        return this.recognizer = new this.sphinx.Recognizer();
      });
      return afterEach(function() {
        return this.recognizer["delete"]();
      });
    });
  });

}).call(this);
