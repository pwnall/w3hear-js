// Generated by CoffeeScript 1.8.0
(function() {
  var fs;

  fs = require('fs');

  describe('lib/sphinx/pocketsphinx.js', function() {
    before(function() {
      var Module, digitsJs, sphinxJs;
      sphinxJs = fs.readFileSync('lib/sphinx/pocketsphinx.js', {
        encoding: 'utf8'
      });
      digitsJs = fs.readFileSync('lib/sphinx/models/digits.js', {
        encoding: 'utf8'
      });
      Module = null;
      eval(sphinxJs + ";\n" + digitsJs);
      return this.sphinx = Module;
    });
    it('defines the right APIs', function() {
      expect(this.sphinx).to.have.property('AudioBuffer');
      expect(this.sphinx).to.have.property('Config');
      expect(this.sphinx).to.have.property('Integers');
      expect(this.sphinx).to.have.property('Recognizer');
      expect(this.sphinx).to.have.property('ReturnType');
      expect(this.sphinx).to.have.property('Segmentation');
      expect(this.sphinx).to.have.property('VectorTransitions');
      return expect(this.sphinx).to.have.property('VectorWords');
    });
    describe('ReturnType', function() {
      it('defines SUCCESS', function() {
        return expect(this.sphinx.ReturnType).to.have.property('SUCCESS');
      });
      it('defines BAD_STATE', function() {
        return expect(this.sphinx.ReturnType).to.have.property('BAD_STATE');
      });
      it('defines BAD_ARGUMENT', function() {
        return expect(this.sphinx.ReturnType).to.have.property('BAD_ARGUMENT');
      });
      return it('defines RUNTIME_ERROR', function() {
        return expect(this.sphinx.ReturnType).to.have.property('RUNTIME_ERROR');
      });
    });
    describe('AudioBuffer', function() {
      beforeEach(function() {
        return this.buffer = new this.sphinx.AudioBuffer();
      });
      afterEach(function() {
        return this.buffer["delete"]();
      });
      return it('works like a std::vector of shorts', function() {
        var i, _i, _j;
        expect(this.buffer.size()).to.equal(0);
        for (i = _i = 0; _i < 300; i = ++_i) {
          this.buffer.push_back(i * 100);
          this.buffer.push_back(-i * 100);
        }
        this.buffer.push_back(42);
        expect(this.buffer.size()).to.equal(601);
        for (i = _j = 0; _j < 300; i = ++_j) {
          expect(this.buffer.get(i * 2)).to.equal(i * 100);
          expect(this.buffer.get(i * 2 + 1)).to.equal(-i * 100);
        }
        expect(this.buffer.get(600)).to.equal(42);
        return expect(this.buffer.get(601)).to.equal(void 0);
      });
    });
    describe('Config', function() {
      beforeEach(function() {
        return this.config = new this.sphinx.Config();
      });
      afterEach(function() {
        return this.config["delete"]();
      });
      return it('works like a std::vector of string pairs', function() {
        expect(this.config.size()).to.equal(0);
        this.config.push_back(['-hmm', 'en']);
        expect(this.config.size()).to.equal(1);
        expect(this.config.get(0)[0]).to.equal('-hmm');
        expect(this.config.get(0)[1]).to.equal('en');
        return expect(this.config.get(1)).to.equal(void 0);
      });
    });
    describe('Integers', function() {
      beforeEach(function() {
        return this.vector = new this.sphinx.Integers();
      });
      afterEach(function() {
        return this.vector["delete"]();
      });
      return it('works like a std::vector of ints', function() {
        var i, _i, _j;
        expect(this.vector.size()).to.equal(0);
        for (i = _i = 0; _i < 300; i = ++_i) {
          this.vector.push_back(i * 10000);
          this.vector.push_back(-i * 10000);
        }
        this.vector.push_back(424242);
        expect(this.vector.size()).to.equal(601);
        for (i = _j = 0; _j < 300; i = ++_j) {
          expect(this.vector.get(i * 2)).to.equal(i * 10000);
          expect(this.vector.get(i * 2 + 1)).to.equal(-i * 10000);
        }
        expect(this.vector.get(600)).to.equal(424242);
        return expect(this.vector.get(601)).to.equal(void 0);
      });
    });
    describe('Segmentation', function() {
      beforeEach(function() {
        return this.segmentation = new this.sphinx.Segmentation();
      });
      afterEach(function() {
        return this.segmentation["delete"]();
      });
      return it('works like a std::vector of structs', function() {
        expect(this.segmentation.size()).to.equal(0);
        this.segmentation.push_back({
          start: 12,
          end: 13,
          word: 'hello world!'
        });
        expect(this.segmentation.size()).to.equal(1);
        expect(this.segmentation.get(0).start).to.equal(12);
        expect(this.segmentation.get(0).end).to.equal(13);
        expect(this.segmentation.get(0).word).to.equal('hello world!');
        return expect(this.segmentation.get(1)).to.equal(void 0);
      });
    });
    describe('VectorTransitions', function() {
      beforeEach(function() {
        return this.vector = new this.sphinx.VectorTransitions();
      });
      afterEach(function() {
        return this.vector["delete"]();
      });
      return it('works like a std::vector of structs', function() {
        expect(this.vector.size()).to.equal(0);
        this.vector.push_back({
          from: 12,
          to: 13,
          logp: 0,
          word: 'HELLO'
        });
        expect(this.vector.size()).to.equal(1);
        expect(this.vector.get(0).from).to.equal(12);
        expect(this.vector.get(0).to).to.equal(13);
        expect(this.vector.get(0).logp).to.equal(0);
        expect(this.vector.get(0).word).to.equal('HELLO');
        return expect(this.vector.get(1)).to.equal(void 0);
      });
    });
    describe('VectorWords', function() {
      beforeEach(function() {
        return this.vector = new this.sphinx.VectorWords();
      });
      afterEach(function() {
        return this.vector["delete"]();
      });
      return it('works like a std::vector of string pairs', function() {
        expect(this.vector.size()).to.equal(0);
        this.vector.push_back(['HELLO', 'HH AH L OW']);
        expect(this.vector.size()).to.equal(1);
        expect(this.vector.get(0)[0]).to.equal('HELLO');
        expect(this.vector.get(0)[1]).to.equal('HH AH L OW');
        return expect(this.vector.get(1)).to.equal(void 0);
      });
    });
    return describe('Recognizer', function() {
      beforeEach(function() {
        this.config = new this.sphinx.Config();
        this.config.push_back(['-hmm', 'models/digits']);
        this.config.push_back(['-dict', 'models/digits.dic']);
        this.config.push_back(['-lm', 'models/digits.DMP']);
        return this.recognizer = new this.sphinx.Recognizer(this.config);
      });
      afterEach(function() {
        this.recognizer["delete"]();
        return this.config["delete"]();
      });
      describe('#addWords', function() {
        beforeEach(function() {
          this.words = new this.sphinx.VectorWords();
          this.words.push_back(['ZER', 'Z_zero II_zero R_zero']);
          this.words.push_back(['SEV', 'S_seven EH_seven V_seven']);
          return this.status = this.recognizer.addWords(this.words);
        });
        afterEach(function() {
          return this.words["delete"]();
        });
        return it('succeeds with good data', function() {
          return expect(this.status).to.equal(this.sphinx.ReturnType.SUCCESS);
        });
      });
      describe('#addGrammar', function() {
        beforeEach(function() {
          this.transitions = new this.sphinx.VectorTransitions();
          this.transitions.push_back({
            from: 0,
            to: 1,
            logp: 0,
            word: 'ZERO'
          });
          this.transitions.push_back({
            from: 1,
            to: 2,
            logp: 0,
            word: 'SEVEN'
          });
          this.transitions.push_back({
            from: 1,
            to: 2,
            logp: 0,
            word: ''
          });
          this.ids = new this.sphinx.Integers();
          return this.status = this.recognizer.addGrammar(this.ids, {
            start: 1,
            end: 2,
            numStates: 3,
            transitions: this.transitions
          });
        });
        afterEach(function() {
          this.transitions["delete"]();
          return this.ids["delete"]();
        });
        it('succeeds with good data', function() {
          return expect(this.status).to.equal(this.sphinx.ReturnType.SUCCESS);
        });
        return it('populates the ids input vector', function() {
          return expect(this.ids.size()).to.equal(1);
        });
      });
      describe('#addKeyword', function() {
        beforeEach(function() {
          this.ids = new this.sphinx.Integers();
          return this.status = this.recognizer.addKeyword(this.ids, 'ZERO ZERO SEVEN');
        });
        afterEach(function() {
          return this.ids["delete"]();
        });
        it('succeeds with good data', function() {
          return expect(this.status).to.equal(this.sphinx.ReturnType.SUCCESS);
        });
        return it('populates the ids input vector', function() {
          return expect(this.ids.size()).to.equal(1);
        });
      });
      describe('#switchSearch', function() {
        beforeEach(function() {
          var ids, transitions;
          ids = new this.sphinx.Integers();
          this.recognizer.addKeyword(ids, 'ZERO ZERO SEVEN');
          this.keywordId = ids.get(0);
          ids["delete"]();
          transitions = new this.sphinx.VectorTransitions();
          transitions.push_back({
            from: 0,
            to: 1,
            logp: 0,
            word: 'ZERO'
          });
          transitions.push_back({
            from: 1,
            to: 2,
            logp: 0,
            word: 'SEVEN'
          });
          transitions.push_back({
            from: 1,
            to: 2,
            logp: 0,
            word: ''
          });
          ids = new this.sphinx.Integers();
          this.recognizer.addGrammar(ids, {
            start: 1,
            end: 2,
            numStates: 3,
            transitions: transitions
          });
          this.grammarId = ids.get(0);
          ids["delete"]();
          return transitions["delete"]();
        });
        it('works with a grammar', function() {
          return expect(this.recognizer.switchSearch(this.grammarId)).to.equal(this.sphinx.ReturnType.SUCCESS);
        });
        return it('works with a keyword', function() {
          return expect(this.recognizer.switchSearch(this.keywordId)).to.equal(this.sphinx.ReturnType.SUCCESS);
        });
      });
      return describe('#start / #process / #stop', function() {
        beforeEach(function() {
          var i, _i, _results;
          this.silence = new this.sphinx.AudioBuffer();
          _results = [];
          for (i = _i = 0; _i < 1024; i = ++_i) {
            _results.push(this.silence.push_back(0));
          }
          return _results;
        });
        afterEach(function() {
          return this.silence["delete"]();
        });
        return it('works on silence', function() {
          expect(this.recognizer.start()).to.equal(this.sphinx.ReturnType.SUCCESS);
          expect(this.recognizer.process(this.silence)).to.equal(this.sphinx.ReturnType.SUCCESS);
          expect(this.recognizer.getHyp()).to.equal('');
          return expect(this.recognizer.stop()).to.equal(this.sphinx.ReturnType.SUCCESS);
        });
      });
    });
  });

}).call(this);
